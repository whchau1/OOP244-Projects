/***********************************************************************
// OOP244 Workshop #9 p2: reflection
//
// File	reflect.txt
// -----------------------------------------------------------
// Name            Date            Reason
// Wing Ho Chau
// Seneca Email: whchau1@myseneca.ca
// Seneca ID: 150924231
// I have done all the coding by myself and only copied the code that my professor provided to complete my workshops and assignments.
/////////////////////////////////////////////////////////////////
***********************************************************************/
Workshop 9 is a good practice for the previous chapters. I have created a base class 'LibarayItem' and a derived class 'Book' which is inherited from the base class 'LibraryItem'. In both base class and derived class, they both have a dynamically allocated member. For the class that has dynamically allocated members, we need to apply rules of 3. Rule of 3 is copy constructor, copy assignment operator, and destructor. Copy constructor and copy assignment operator help us manage dynamic resources when we copy the value from the current object to the destination object. The compiler will execute the default copy behavior if we don't apply those two rules. The dynamically allocated member in the destination object will point to the dynamically allocated member in the current object instead of getting a copy. If we delete the object that copied from, it will affect the data member in the object copied to. For destructor, we need to release allocated memory when we don't need the object or the object is out of scope. It will have memory leak if we don't do it.
Also, I have practice how to apply polymorphism. The keyword 'virtual' will enable dynamic dispatch. It will let the compile get the member function in the derived class instead of the base class. If we want to get the member function from base class, we can use the scope resolution operator to call the member function.