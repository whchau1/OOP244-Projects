/***********************************************************************
// OOP244 Workshop #7 p2: reflection
//
// File	reflect.txt
// -----------------------------------------------------------
// Name            Date            Reason
// Wing Ho Chau
// Seneca Email: whchau1@myseneca.ca
// Seneca ID: 150924231
// I have done all the coding by myself and only copied the code that my professor provided to complete my workshops and assignments.
/////////////////////////////////////////////////////////////////
***********************************************************************/
In Workshop 7, I tried to create a derived class SavingsAccount inherit from a base class BankAccount. To create a derived class, we use the syntax 'class derivedClassName : public baseClassName'. For the keyword 'public' here, it defines that all members in the base class remain the same accessibility. This means base class public and protected members are accessible, and private members remain non-accessible. For the keyword 'protected' in the base class, it tells us that the members in it are only accessible by the derived class and inaccessible by other classes. Furthermore, the derived class function will shadow the base class function when they both have the same function. For example, write() and read() function in the class SavingsAccount shadow both function in the class BankAccount. When we call SavingsAccount.write(), it will run the code SavingsAccount::write(). If we don't define the write() function in the derived class, it will call back the base class function BankAccount::write(). To access the function in the base class, the function needs to be protected or public. Then we access with scope resolution operator '::'. To initialize the base class data member, we initialize it after the parenthesis of the parameter list instead of the definition. If we do it in definition, it will only create a no-name object and disappear at the same line.

In milestone 2, I create a module IOAble. It has a interface called class IOAble. Inside IOAble, members are pure virtual. The keyword 'virtual' will let the base class function get at latest version of the function definition from derived class. To make it pure virtual, we make it equal to 0. It won't let it has any defintion, but it asks the derived class must define the function in their member list. For destructor, we cannot make it pure virtual because a destructor must has definition.